<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConversationsEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">conversations-engine</a> &gt; <a href="index.source.html" class="el_package">conversations_engine</a> &gt; <span class="el_source">ConversationsEngine.java</span></div><h1>ConversationsEngine.java</h1><pre class="source lang-java linenums">package conversations_engine;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.json.JSONObject;

import interfaces.INLPAnswer;
import interfaces.INLPComponent;
import interfaces.ISkill;
import interfaces.ISkillAnswer;

/**
 * ConversationsEngine is a framework that is supposed to be used as a dialog
 * management system. It is designed to simplify the creation of chatbots by
 * combining {@link ISkill skills} and a single {@link INLPComponent
 * NLP-Component} into an all in one system.&lt;br&gt;
 * &lt;br&gt;
 * The system is based on a finite state machine to create an accessible testing
 * environment.
 * 
 * @author Marcel Engelmann
 *
 */
public class ConversationsEngine {

	private static final int DEFAULTTIMEOUTVALUE = 300;
	private static final String EMPTYCONTEXTOBJECT = &quot;{}&quot;;

	private State currentState;
	private SkillStateMachine currentSkillStateMachine;
	private SkillStateMachine lastUsedSkillStateMachine;
	private PendingQuestions pendingSkillQuestions;
	private JSONObject contextObject;
	private Timer timer;
	private String lastIntent;
	private INLPComponent nlpComponent;
	private List&lt;String&gt; possibleSkillsForChooseSkillQuestion;
	private List&lt;SkillStateMachine&gt; allSkillStateMachines;
	private Deque&lt;String&gt; pendingIntents;
	private boolean wasLastQuestionChooseSkill;
	private boolean wasLastQuestionSkillQuestion;
	private boolean wasLastQuestionAbortQuestion;
	private boolean wasLastQuestionReturnToPreviousSkill;
	private boolean closed;
	private int timeoutInSeconds;

	/**
	 * Creates a new {@link ConversationsEngine} object
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param timeoutInSeconds  the number of seconds after which the
	 *                          {@link ConversationsEngine} will transition into the
	 *                          sleepState. The timer refreshes after each
	 *                          interaction.
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 * @throws IllegalArgumentException if the {@link INLPComponent} is null or the
	 *                                  timeout value is less than 1
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds, String jsonContextObject)
<span class="fc" id="L73">			throws IllegalArgumentException {</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (nlpComponent == null) {</span>
<span class="fc" id="L75">			Logging.error(&quot;INLPComponent is null&quot;);</span>
<span class="fc" id="L76">			throw new IllegalArgumentException(&quot;INLPComponent is null&quot;);</span>
		}

<span class="fc bfc" id="L79" title="All 2 branches covered.">		if (timeoutInSeconds &lt;= 0) {</span>
<span class="fc" id="L80">			Logging.error(&quot;Timeout value must be greater than 0&quot;);</span>
<span class="fc" id="L81">			throw new IllegalArgumentException(&quot;Timeout value must be greater than 0&quot;);</span>
		}
<span class="fc" id="L83">		State defaultState = new State(&quot;defaultState&quot;);</span>
<span class="fc" id="L84">		State sleepState = new State(&quot;sleepState&quot;);</span>
<span class="fc" id="L85">		defaultState.addTransition(new Transition(sleepState, &quot;SLEEP&quot;));</span>
<span class="fc" id="L86">		sleepState.addTransition(new Transition(defaultState, &quot;WAKEUP&quot;));</span>
<span class="fc" id="L87">		this.currentState = defaultState;</span>
<span class="fc" id="L88">		this.nlpComponent = nlpComponent;</span>
<span class="fc" id="L89">		this.contextObject = new JSONObject(jsonContextObject);</span>
<span class="fc" id="L90">		this.allSkillStateMachines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L91">		this.possibleSkillsForChooseSkillQuestion = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L92">		this.pendingSkillQuestions = new PendingQuestions();</span>
<span class="fc" id="L93">		this.pendingIntents = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L94">		this.lastIntent = &quot;&quot;;</span>
<span class="fc" id="L95">		this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L96">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L97">		this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L98">		this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L99">		this.closed = false;</span>
<span class="fc" id="L100">		this.timeoutInSeconds = timeoutInSeconds;</span>
<span class="fc" id="L101">		I18n.setDefaultLanguage(new Locale(&quot;de&quot;, &quot;DE&quot;));</span>
		// the list of intents the ConversationsEngine uses itself (as trigger words)
<span class="fc" id="L103">		List&lt;String&gt; triggerIntents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L104">		triggerIntents.add(&quot;abort&quot;);</span>
<span class="fc" id="L105">		triggerIntents.add(&quot;last&quot;);</span>
<span class="fc" id="L106">		triggerIntents.add(&quot;all&quot;);</span>
<span class="fc" id="L107">		triggerIntents.add(&quot;yes&quot;);</span>
<span class="fc" id="L108">		triggerIntents.add(&quot;no&quot;);</span>
<span class="fc" id="L109">		this.nlpComponent.addUsedIntents(triggerIntents);</span>
<span class="fc" id="L110">		this.timer = new Timer();</span>
<span class="fc" id="L111">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L112">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * 300 seconds and an empty context object
	 * 
	 * @param nlpComponent the NLPComponent that handles the user input
	 */
	public ConversationsEngine(INLPComponent nlpComponent) {
<span class="fc" id="L121">		this(nlpComponent, DEFAULTTIMEOUTVALUE, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L122">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with an empty context object
	 * 
	 * @param nlpComponent     the NLPComponent that handles the user input
	 * @param timeoutInSeconds the number of seconds after which the
	 *                         {@link ConversationsEngine} will transition into the
	 *                         sleepState. The timer refreshes after each
	 *                         interaction.
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds) {
<span class="fc" id="L134">		this(nlpComponent, timeoutInSeconds, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L135">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * 300 seconds
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 */
	public ConversationsEngine(INLPComponent nlpComponent, String jsonContextObject) {
<span class="fc" id="L146">		this(nlpComponent, DEFAULTTIMEOUTVALUE, jsonContextObject);</span>
<span class="fc" id="L147">	}</span>

	/**
	 * Returns the state machine's current state
	 * 
	 * @return the state machine's current state
	 */
	public String getState() {
<span class="fc bfc" id="L155" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L156">			logIllegalAccess();</span>
<span class="fc" id="L157">			return &quot;&quot;;</span>
		}
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">		if (this.currentSkillStateMachine != null &amp;&amp; !&quot;sleepState&quot;.equalsIgnoreCase(this.currentState.getName()))</span>
<span class="fc" id="L160">			return this.currentSkillStateMachine.getCurrentState().getName();</span>
<span class="fc" id="L161">		return this.currentState.getName();</span>
	}

	/**
	 * Add a new Skill to the {@link ConversationsEngine}
	 * 
	 * @param skill            the skill to add to the {@link ConversationsEngine}
	 * @param jsonStateMachine the skill's state machine in JSON-Format. For the
	 *                         JSON-Schema please check out the &lt;a href=
	 *                         &quot;file:../../resources/SkillStateMachine_Schema.json&quot;&gt;Schema.json&lt;/a&gt;
	 *                         file
	 */
	public void addSkill(ISkill skill, String jsonStateMachine) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L175">			logIllegalAccess();</span>
<span class="fc" id="L176">			return;</span>
		}
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (skill == null) {</span>
<span class="fc" id="L179">			Logging.error(&quot;The skill to add to the ConversationsEngine is null&quot;);</span>
<span class="fc" id="L180">			return;</span>
		}

<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (jsonStateMachine.isBlank()) {</span>
<span class="fc" id="L184">			Logging.error(&quot;The JSON-String for the skill to add to the ConversationsEngine is blank&quot;, skill);</span>
<span class="fc" id="L185">			return;</span>
		}
<span class="fc" id="L187">		SkillStateMachine newSkillStateMachine = GenerateSkillStateMachine.fromJson(skill, jsonStateMachine,</span>
				nlpComponent);
<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (newSkillStateMachine == null) {</span>
<span class="fc" id="L190">			Logging.error(&quot;Could not add the skill from the jsonString {}&quot;, jsonStateMachine);</span>
<span class="fc" id="L191">			return;</span>
		}

<span class="fc bfc" id="L194" title="All 2 branches covered.">		if (allSkillStateMachines.stream().anyMatch(</span>
<span class="fc" id="L195">				skillStateMachine -&gt; skillStateMachine.getName().equalsIgnoreCase(newSkillStateMachine.getName()))) {</span>
<span class="fc" id="L196">			Logging.error(&quot;The skill {} already exists&quot;, newSkillStateMachine.getName());</span>
<span class="fc" id="L197">			return;</span>
		}

<span class="fc" id="L200">		allSkillStateMachines.add(newSkillStateMachine);</span>
<span class="fc" id="L201">	}</span>

	/**
	 * Shuts this ConversationsEngine object down and invokes the given Consumer
	 * operation with the current context object as a StringBuilder
	 * 
	 * @param operation the operation to call, with the context object passed as
	 *                  parameter, after shutting down.
	 */
	public void shutdown(Consumer&lt;StringBuilder&gt; operation) {
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L212">			logIllegalAccess();</span>
<span class="fc" id="L213">			return;</span>
		}
<span class="fc" id="L215">		Logging.debug(&quot;Shutting down the ConversationsEngine {}&quot;, this);</span>
<span class="fc" id="L216">		this.timer.cancel();</span>
<span class="fc" id="L217">		this.closed = true;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">		if (operation == null) {</span>
<span class="fc" id="L219">			Logging.warn(&quot;The consumer passed to the shutdown function was null&quot;);</span>
<span class="fc" id="L220">			return;</span>
		}
<span class="fc" id="L222">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L223">		sb.append(this.contextObject);</span>
<span class="fc" id="L224">		this.contextObject = new JSONObject();</span>
<span class="fc" id="L225">		operation.accept(sb);</span>
<span class="fc" id="L226">	}</span>

	/**
	 * Processes a new input and returns a {@link List} of answers
	 * 
	 * @param input the input to process
	 * @return a {@link List} of answers
	 */
	public List&lt;String&gt; userInput(String input) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L236">			logIllegalAccess();</span>
<span class="fc" id="L237">			return new ArrayList&lt;&gt;();</span>
		}
<span class="fc bfc" id="L239" title="All 4 branches covered.">		if (input == null || input.isBlank()) {</span>
<span class="fc" id="L240">			Logging.warn(&quot;The user input was null or blank&quot;);</span>
<span class="fc" id="L241">			this.defaultErrorUserOuput();</span>
<span class="fc" id="L242">			return UserOutput.popNextOutput();</span>
		}
<span class="fc" id="L244">		Logging.userInput(input);</span>
<span class="fc" id="L245">		leaveSleepState();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">		if (this.wasLastQuestionSkillQuestion) {</span>
<span class="fc" id="L247">			processSkillQuestion(input);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">		} else if (this.wasLastQuestionChooseSkill) {</span>
<span class="fc" id="L249">			processChooseSkillQuestion(input);</span>
		} else {
<span class="fc" id="L251">			processNormalRequest(input);</span>
		}
<span class="fc" id="L253">		String currentSkillName = &quot;&quot;;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L255">			currentSkillName = &quot; within the skill &quot; + this.currentSkillStateMachine.getName();</span>
		}
<span class="fc" id="L257">		Logging.debug(&quot;The ConversationsEngine is currently in the state: {}{}&quot;, this.getState(), currentSkillName);</span>
<span class="fc" id="L258">		return UserOutput.popNextOutput();</span>
	}

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param input the user input
	 */
	private void processNormalRequest(String input) {
<span class="fc" id="L268">		processINLPAnswer(this.nlpComponent.understandInput(input, this.contextObject));</span>

<span class="fc" id="L270">	}</span>

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param processedInput the {@link INLPAnswer} of a {@link INLPComponent}
	 */
	private void processINLPAnswer(INLPAnswer processedInput) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">		if (processedInput == null) {</span>
<span class="fc" id="L280">			Logging.error(&quot;NLP Component's returned INLPAnswer is null&quot;);</span>
<span class="fc" id="L281">			this.defaultErrorUserOuput();</span>
<span class="fc" id="L282">			return;</span>
		}
<span class="fc" id="L284">		List&lt;String&gt; intents = processedInput.getIntents();</span>
<span class="fc" id="L285">		Locale foundLanguage = processedInput.getInputLanguage();</span>
<span class="fc" id="L286">		boolean addedEntities = processedInput.hasAddedEntities();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">		if (foundLanguage == null) {</span>
<span class="fc" id="L288">			Logging.error(&quot;NLPComponent did not return a language&quot;);</span>
		} else {
<span class="fc" id="L290">			I18n.setLanguage(foundLanguage);</span>
		}
		// If the NLPAnswer has no result -&gt; treat it as bad input
<span class="fc bfc" id="L293" title="All 6 branches covered.">		if (!addedEntities &amp;&amp; (intents == null || intents.isEmpty())) {</span>
<span class="fc" id="L294">			this.defaultErrorUserOuput();</span>
<span class="fc" id="L295">			return;</span>
		}
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">		if (intents != null &amp;&amp; !intents.isEmpty()) {</span>
			// keep the correct input order for the stack/dequeue
<span class="fc" id="L299">			Collections.reverse(intents);</span>
<span class="fc" id="L300">			this.pendingIntents.addAll(intents);</span>
<span class="fc bfc" id="L301" title="All 4 branches covered.">			if (this.wasLastQuestionAbortQuestion || this.wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L302">				processSpecialQuestion();</span>
<span class="fc" id="L303">				return;</span>
			}
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (&quot;abort&quot;.equalsIgnoreCase(intents.get(0))) {</span>
<span class="fc" id="L306">				this.pendingIntents.removeLast();</span>
<span class="fc" id="L307">				abortRequested();</span>
<span class="fc" id="L308">				return;</span>
			}
		}
<span class="fc" id="L311">		evaluateNextAction();</span>
<span class="fc" id="L312">	}</span>

	private void processSpecialQuestion() {
<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (this.wasLastQuestionAbortQuestion) {</span>
<span class="fc" id="L316">			this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L317">			processAbortQuestion();</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">		} else if (wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L319">			this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L320">			processReturnToPreviousSkillQuestion();</span>
		}

<span class="fc" id="L323">	}</span>

	/**
	 * Tries to process the intent as an answer to an abort question &lt;br&gt;
	 * &lt;br&gt;
	 * If the answer was to abort the last skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine reset} and the next action will be
	 * {@link #evaluateNextAction() evaluated} &lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline cleared} &lt;br&gt;
	 * If the abort question was not answered, the input will be processed
	 * {@link #processNormalRequest(String)}
	 * 
	 * @param intent the intent to process
	 */
	private void processAbortQuestion() {
<span class="fc" id="L341">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">		if (&quot;last&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L343">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L344">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L345">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L346">			evaluateNextAction();</span>
<span class="fc" id="L347">			return;</span>
		}
<span class="fc bfc" id="L349" title="All 2 branches covered.">		if (&quot;all&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L350">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L351">			this.clearPipeline();</span>
<span class="fc" id="L352">			return;</span>
		}
<span class="fc" id="L354">		askAbortQuestion();</span>
<span class="fc" id="L355">	}</span>

	/**
	 * Tries to process the intent as an answer to the &quot;Return to the previous
	 * skill&quot; question&lt;br&gt;
	 * &lt;br&gt;
	 * 
	 * If the answer was to return to the next skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine(boolean) reset}&lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline() cleared}&lt;br&gt;
	 * 
	 * If the abort question was not answered, the input will be processed
	 * {@link #processNormalRequest normally}
	 * 
	 * @param intent the intent to process
	 * 
	 */
	private void processReturnToPreviousSkillQuestion() {
<span class="fc" id="L376">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">		if (&quot;Yes&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L378">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L379">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L380">			evaluateNextAction();</span>
<span class="fc" id="L381">			return;</span>
		}
<span class="fc bfc" id="L383" title="All 2 branches covered.">		if (&quot;No&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L384">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L385">			resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L386">			return;</span>
		}
<span class="fc" id="L388">		askContinueLastSkill();</span>
<span class="fc" id="L389">	}</span>

	/**
	 * Tries to process the input as an answer to a skill question. If the question
	 * was not answered, the corresponding skill will have to ask the question again
	 * 
	 * @param input the input to process
	 */
	private void processSkillQuestion(String input) {
<span class="fc" id="L398">		this.wasLastQuestionSkillQuestion = false;</span>
		INLPAnswer processedInput;
<span class="fc" id="L400">		String entityName = this.pendingSkillQuestions.getTopEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L401">		processedInput = this.nlpComponent.understandInput(input, entityName, this.contextObject);</span>
		// Remove last asked question. If the question was not answered, then the
		// corresponding skill will have to ask the same question again
<span class="fc" id="L404">		this.pendingSkillQuestions.removeTopQuestionAndEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L405">		processINLPAnswer(processedInput);</span>
<span class="fc" id="L406">	}</span>

	/**
	 * Tries to process the input as an answer to a question to choose a skill&lt;br&gt;
	 * &lt;br&gt;
	 * If the input equals to a fitting skill, that skill will be executed and the
	 * last intent will be processed Otherwise the input will be processed as a
	 * {@link #processNormalRequest normal request}
	 * 
	 * @param input the input to process
	 */
	private void processChooseSkillQuestion(String input) {
		// match input to possible skills to choose from
<span class="fc" id="L419">		String nextSkill = this.possibleSkillsForChooseSkillQuestion.stream().filter(input::equalsIgnoreCase)</span>
<span class="fc" id="L420">				.findFirst().orElse(&quot;&quot;);</span>

<span class="fc bfc" id="L422" title="All 2 branches covered.">		if (nextSkill.isEmpty()) {</span>
<span class="fc" id="L423">			Logging.debug(</span>
					&quot;The question to choose a skill was not answered!\nPossible skills are: {}\nUser input is: {}&quot;,
					this.possibleSkillsForChooseSkillQuestion, input);
<span class="fc" id="L426">			askChooseSkillQuestion();</span>
		} else {
<span class="fc" id="L428">			this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L429">			final String skillName = nextSkill;</span>
<span class="fc" id="L430">			leaveCurrentSkillStateMachine();</span>
<span class="fc" id="L431">			this.currentSkillStateMachine = this.allSkillStateMachines.stream()</span>
<span class="fc" id="L432">					.filter(skill -&gt; skill.getName().equals(skillName)).findFirst().orElse(null);</span>
<span class="fc" id="L433">			evaluateNextAction();</span>
<span class="fc" id="L434">			this.possibleSkillsForChooseSkillQuestion.clear();</span>
		}
<span class="fc" id="L436">	}</span>

	/**
	 * Processes the next {@link #pendingIntents intent}
	 *
	 */
	private void processNextIntent() {
<span class="fc" id="L443">		String intent = pendingIntents.peekLast();</span>
<span class="fc" id="L444">		Logging.debug(&quot;Processing the intent '{}'&quot;, intent);</span>
<span class="fc" id="L445">		this.lastIntent = intent;</span>
<span class="fc" id="L446">		SkillStateMachine nextSkillStateMachine = getNextSkillStateMachine(intent);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">		if (nextSkillStateMachine == null) {</span>
<span class="fc" id="L448">			return;</span>
		}
<span class="fc" id="L450">		this.currentSkillStateMachine = nextSkillStateMachine;</span>

<span class="fc" id="L452">		ISkillAnswer answer = this.currentSkillStateMachine.execute(intent, this.contextObject);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">		if (answer == null) {</span>
<span class="fc" id="L454">			this.defaultErrorUserOuput();</span>
<span class="fc" id="L455">			return;</span>
		}

<span class="fc" id="L458">		this.processSkillAnswer(answer);</span>
<span class="fc" id="L459">		boolean skillMachineEnded = this.hasSkillStateMachineEnded();</span>
<span class="fc bfc" id="L460" title="All 4 branches covered.">		if (skillMachineEnded &amp;&amp; this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L461">			wasLastQuestionReturnToPreviousSkill = true;</span>
<span class="fc" id="L462">			askContinueLastSkill();</span>
<span class="fc" id="L463">			return;</span>
		}
<span class="fc" id="L465">		evaluateNextAction();</span>
<span class="fc" id="L466">	}</span>

	/**
	 * Processes a {@link ISkillAnswer} of a skill
	 * 
	 * @param skillAnswer the answer of a skill
	 */
	private void processSkillAnswer(ISkillAnswer skillAnswer) {
<span class="fc" id="L474">		boolean answerIsEmpty = true;</span>
<span class="fc bfc" id="L475" title="All 4 branches covered.">		if (skillAnswer.answers() != null &amp;&amp; !skillAnswer.answers().isEmpty()) {</span>
<span class="fc" id="L476">			UserOutput.addOutputMessages(skillAnswer.answers());</span>
<span class="fc" id="L477">			answerIsEmpty = false;</span>
		}
<span class="fc bfc" id="L479" title="All 2 branches covered.">		if (skillAnswer.skipUserOutput()) {</span>
<span class="fc" id="L480">			Logging.debug(&quot;Skipping user Output&quot;);</span>
<span class="fc" id="L481">			return;</span>
		}
<span class="fc bfc" id="L483" title="All 2 branches covered.">		if (skillAnswer.requiredQuestionsToBeAnswered() == null</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">				|| skillAnswer.requiredQuestionsToBeAnswered().isEmpty()) {</span>
			// remove last processed intent
<span class="fc" id="L486">			this.pendingIntents.removeLast();</span>
			// no skill answer and no skill question
<span class="fc bfc" id="L488" title="All 2 branches covered.">			if (answerIsEmpty) {</span>
<span class="fc" id="L489">				Logging.error(&quot;The Skill {} returned no answer and no questions&quot;,</span>
<span class="fc" id="L490">						this.currentSkillStateMachine.getName());</span>
			}
<span class="fc" id="L492">			return;</span>
		}
<span class="fc" id="L494">		Map&lt;String, String&gt; newQuestions = skillAnswer.requiredQuestionsToBeAnswered();</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">		for (Entry&lt;String, String&gt; entry : newQuestions.entrySet()) {</span>
<span class="fc" id="L496">			this.pendingSkillQuestions.addQuestion(this.currentSkillStateMachine.getName(), entry.getKey(),</span>
<span class="fc" id="L497">					entry.getValue());</span>
<span class="fc" id="L498">		}</span>
<span class="fc" id="L499">	}</span>

	/**
	 * Evaluates the next possible action. &lt;br&gt;
	 */
	private void evaluateNextAction() {

		// if the intent is still the same and the skill for the intent has questions
		// left to ask of the user
<span class="fc bfc" id="L508" title="All 4 branches covered.">		if (this.currentSkillStateMachine != null &amp;&amp; !this.pendingIntents.isEmpty()</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">				&amp;&amp; this.lastIntent.equals(this.pendingIntents.peekLast())</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">				&amp;&amp; this.pendingSkillQuestions.getNumberOfQuestions(this.currentSkillStateMachine.getName()) &gt; 0) {</span>
<span class="fc" id="L511">			askNextQuestion();</span>
<span class="fc" id="L512">			return;</span>

		}

<span class="fc bfc" id="L516" title="All 2 branches covered.">		if (!this.pendingIntents.isEmpty()) {</span>
<span class="fc" id="L517">			processNextIntent();</span>
		}
<span class="fc" id="L519">	}</span>

	/**
	 * If {@link #lastUsedSkillStateMachine} is null, then the {@link #clearPipeline
	 * pipeline will be cleared} &lt;br&gt;
	 * If not then an abort question will be asked
	 */
	private void abortRequested() {
		// can only abort current skillSM
<span class="fc bfc" id="L528" title="All 2 branches covered.">		if (this.lastUsedSkillStateMachine == null) {</span>
<span class="fc" id="L529">			this.clearPipeline();</span>
<span class="fc" id="L530">			return;</span>
		}
<span class="fc" id="L532">		this.wasLastQuestionAbortQuestion = true;</span>
<span class="fc" id="L533">		askAbortQuestion();</span>
<span class="fc" id="L534">	}</span>

	/**
	 * Resets the {@link ConversationsEngine} to the initial state, except for the
	 * {@link #contextObject}
	 */
	private void clearPipeline() {
		// reset both, the current and last skillStateMachine
<span class="fc" id="L542">		resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L543">		this.pendingIntents.clear();</span>
<span class="fc" id="L544">		this.pendingSkillQuestions.clear();</span>
<span class="fc" id="L545">		wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L546">		wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L547">		wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L548">		wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L549">		possibleSkillsForChooseSkillQuestion.clear();</span>
<span class="fc" id="L550">		lastIntent = &quot;&quot;;</span>
<span class="fc" id="L551">	}</span>

	/**
	 * Creates a new {@link Timer} that transitions the {@link ConversationsEngine}
	 * into the sleepState after {@link #timeoutInSeconds } seconds and if an old
	 * timer exists, cancels it
	 */
	private void scheduleNewTimeoutTask() {
		// This could be extended
<span class="fc" id="L560">		TimerTask timerTask = new TimerTask() {</span>
			@Override
			public void run() {
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">				if (&quot;defaultState&quot;.equals(currentState.getName())) {</span>
<span class="fc" id="L564">					Logging.debug(&quot;Entering Sleep State&quot;);</span>
<span class="fc" id="L565">					currentState = currentState.getNextState(&quot;SLEEP&quot;);</span>
				}
<span class="fc" id="L567">			}</span>
		};
<span class="fc" id="L569">		this.timer.cancel();</span>
<span class="fc" id="L570">		this.timer = new Timer();</span>
<span class="fc" id="L571">		this.timer.schedule(timerTask, this.timeoutInSeconds * 1000L);</span>
<span class="fc" id="L572">	}</span>

	/**
	 * Resets the {@link #timer}.&lt;br&gt;
	 * If the {@link ConversationsEngine} is currently in the sleepState, then it
	 * will transition to the defaultState
	 */
	private void leaveSleepState() {
<span class="fc bfc" id="L580" title="All 2 branches covered.">		if (&quot;sleepState&quot;.equals(this.currentState.getName())) {</span>
<span class="fc" id="L581">			Logging.debug(&quot;Leaving Sleep State&quot;);</span>
<span class="fc" id="L582">			this.currentState = this.currentState.getNextState(&quot;WAKEUP&quot;);</span>
<span class="fc" id="L583">			UserOutput.addOutputMessageFromLocalizationKey(&quot;WelcomeBack&quot;);</span>
		}

<span class="fc" id="L586">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L587">	}</span>

	/**
	 * Adds the next question of a skill to the {@link UserOutput}
	 */
	private void askNextQuestion() {
<span class="fc" id="L593">		String nextQuestion = this.pendingSkillQuestions.getTopQuestion(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L594">		UserOutput.addOutputQuestion(nextQuestion);</span>
<span class="fc" id="L595">		this.wasLastQuestionSkillQuestion = true;</span>
<span class="fc" id="L596">	}</span>

	/**
	 * Adds the question of choosing a skill to the {@link UserOutput}
	 */
	private void askChooseSkillQuestion() {
<span class="fc" id="L602">		UserOutput.addOutputMessageFromLocalizationKey(&quot;MultipleSkills&quot;,</span>
<span class="fc" id="L603">				this.possibleSkillsForChooseSkillQuestion.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="fc" id="L604">	}</span>

	/**
	 * Adds the question, weather the user wants to abort the last or all skills, to
	 * the {@link UserOutput}
	 */
	private void askAbortQuestion() {
<span class="fc" id="L611">		UserOutput.addOutputMessageFromLocalizationKey(&quot;AbortQuestion&quot;);</span>
<span class="fc" id="L612">	}</span>

	/**
	 * Adds the question weather the user wants to continue the last skill, to the
	 * {@link UserOutput}
	 */
	private void askContinueLastSkill() {
<span class="fc" id="L619">		UserOutput.addOutputMessageFromLocalizationKey(&quot;ContinueLastSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L620">	}</span>

	/**
	 * Determines the possible skills for a given intent
	 * 
	 * @param intent the intent thats supposed to be processed by a skill
	 * @return the {@link SkillStateMachine} to the corresponding skill, that can
	 *         execute the given intent. Or returns null if no or more than one
	 *         skill was found to process the intent
	 */
	private SkillStateMachine getNextSkillStateMachine(String intent) {

<span class="fc bfc" id="L632" title="All 4 branches covered.">		if (this.currentSkillStateMachine != null &amp;&amp; this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L633">			return this.currentSkillStateMachine;</span>
		}

<span class="fc" id="L636">		List&lt;SkillStateMachine&gt; possibleSkills = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">		for (SkillStateMachine ssm : allSkillStateMachines) {</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">			if (ssm.canExecute(intent)) {</span>
<span class="fc" id="L639">				possibleSkills.add(ssm);</span>
			}
<span class="fc" id="L641">		}</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (possibleSkills.isEmpty()) {</span>
<span class="fc" id="L644">			UserOutput.addOutputMessageFromLocalizationKey(&quot;NoSkillFound&quot;);</span>
<span class="fc" id="L645">			Logging.debug(&quot;Could not find a skill to process the intent {}&quot;, intent);</span>
<span class="fc" id="L646">			return null;</span>
		}

<span class="fc bfc" id="L649" title="All 2 branches covered.">		if (possibleSkills.size() &gt; 1) {</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">			for (SkillStateMachine ssm : possibleSkills) {</span>
<span class="fc" id="L651">				this.possibleSkillsForChooseSkillQuestion.add(ssm.getName());</span>
<span class="fc" id="L652">			}</span>
<span class="fc" id="L653">			askChooseSkillQuestion();</span>
<span class="fc" id="L654">			Logging.debug(&quot;The intent {} can be processed by multiple skills: {}&quot;, intent,</span>
					this.possibleSkillsForChooseSkillQuestion);
<span class="fc" id="L656">			this.wasLastQuestionChooseSkill = true;</span>
<span class="fc" id="L657">			return null;</span>
		}

<span class="fc bfc" id="L660" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">				&amp;&amp; !possibleSkills.get(0).getName().equals(currentSkillStateMachine.getName())) {</span>
<span class="fc" id="L662">			leaveCurrentSkillStateMachine();</span>
		}
<span class="fc" id="L664">		return possibleSkills.get(0);</span>

	}

	/**
	 * leaves the {@link #currentSkillStateMachine} and sets it as the
	 * {@link #lastUsedSkillStateMachine}
	 */
	private void leaveCurrentSkillStateMachine() {
<span class="fc bfc" id="L673" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L674">			Logging.debug(&quot;Leaving the skill {}&quot;, this.currentSkillStateMachine.getName());</span>
		}
<span class="fc" id="L676">		this.lastUsedSkillStateMachine = this.currentSkillStateMachine;</span>
<span class="fc" id="L677">	}</span>

	/**
	 * Resets the {@link #currentSkillStateMachine} and removes all pending
	 * questions relating to the skill
	 * 
	 * @param alsoResetLastUsedSkillStateMachine if true, then also resets the
	 *                                           {@link #lastUsedSkillStateMachine}
	 *                                           and removes all pending questions
	 *                                           relating to that skill
	 */
	private void resetCurrentSkillStateMachine(boolean alsoResetLastUsedSkillStateMachine) {
<span class="fc bfc" id="L689" title="All 2 branches covered.">		if (this.currentSkillStateMachine == null) {</span>
<span class="fc" id="L690">			return;</span>
		}
<span class="fc" id="L692">		removeIntentsOfCurrentSkill();</span>
<span class="fc" id="L693">		this.currentSkillStateMachine.reset();</span>
<span class="fc" id="L694">		this.pendingSkillQuestions.removeAllSkillQuestions(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L695">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L696">		this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">		if (alsoResetLastUsedSkillStateMachine) {</span>
<span class="fc" id="L698">			resetCurrentSkillStateMachine(false);</span>
		}
<span class="fc" id="L700">	}</span>

	/**
	 * Removes all {@link #pendingIntents} that the
	 * {@link #currentSkillStateMachine} can execute
	 */
	private void removeIntentsOfCurrentSkill() {
<span class="fc" id="L707">		Iterator&lt;String&gt; iterator = this.pendingIntents.iterator();</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">		while (iterator.hasNext()) {</span>
<span class="fc" id="L709">			String intent = iterator.next();</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">			if (this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L711">				iterator.remove();</span>
			}
<span class="fc" id="L713">		}</span>
<span class="fc" id="L714">	}</span>

	/**
	 * Checks weather the {@link #currentSkillStateMachine} has ended or not
	 * 
	 * @return true if the {@link #currentSkillStateMachine} has ended
	 */
	private boolean hasSkillStateMachineEnded() {
<span class="fc" id="L722">		boolean currentSkillStateMachineEnded = this.currentSkillStateMachine.hasEnded();</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">		if (currentSkillStateMachineEnded) {</span>
<span class="fc" id="L724">			Logging.debug(&quot;The Skill {} Ended&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L725">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L726">			this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc" id="L727">			this.lastUsedSkillStateMachine = null;</span>
		}

<span class="fc" id="L730">		return currentSkillStateMachineEnded;</span>
	}

	/**
	 * Logs that a method on this object was called after it has been shut down
	 */
	private void logIllegalAccess() {
<span class="fc" id="L737">		Logging.error(&quot;The ConversationsEngine was invoked after it has been shut down&quot;);</span>
<span class="fc" id="L738">	}</span>

	/**
	 * TODO: add example request from the skills or the current running skill (if
	 * one is running)
	 */
	private void defaultErrorUserOuput() {
<span class="fc" id="L745">		UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L746">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>